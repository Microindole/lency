// Lency 标准库 - 集合模块 (collections.lcy)
// 提供集合类型和泛型操作
//
// Vec<T> 是编译时内置类型，基本操作由运行时提供。
// 本文件提供更高级的集合操作和 HashMap。

// ============== Pair 类型 ==============

// 泛型键值对
struct Pair<K, V> {
    K key
    V value
}

// 创建 Pair
Pair<K, V> make_pair<K, V>(K key, V value) {
    return Pair<K, V> { key: key, value: value }
}

// ============== Box 类型 ==============

// 简单的包装类型
struct Box<T> {
    T value
}

impl<T> Box<T> {
    // 获取值
    T get() {
        return this.value
    }

    // 设置值
    void set(T new_value) {
        this.value = new_value
    }
}

// 创建 Box
Box<T> box<T>(T value) {
    return Box<T> { value: value }
}

// ============== Vec 辅助函数 ==============
// 注意: 这些函数假设 Vec 已有 len/get/set 方法支持

// 查找元素的索引 (返回 -1 表示未找到)
// 使用 Eq trait 进行比较
int find_index_int(Vec<int> v, int target) {
    var i = 0
    while i < v.len() {
        if v.get(i) == target {
            return i
        }
        i = i + 1
    }
    return -1
}

// 查找字符串元素的索引
int find_index_string(Vec<string> v, string target) {
    var i = 0
    while i < v.len() {
        if v.get(i) == target {
            return i
        }
        i = i + 1
    }
    return -1
}

// 反转 Vec
void reverse<T>(Vec<T> v) {
    var left = 0
    var right = v.len() - 1
    while left < right {
        var tmp = v.get(left)
        v.set(left, v.get(right))
        v.set(right, tmp)
        left = left + 1
        right = right - 1
    }
}

// 获取 Vec 的最后一个元素
T last<T>(Vec<T> v) {
    return v.get(v.len() - 1)
}

// ============== 运行时 Vec FFI (供参考) ==============
//
// lency_vec_new(capacity)          -> *mut LencyVec
// lency_vec_push(vec, element)     -> void
// lency_vec_pop(vec)               -> i64
// lency_vec_len(vec)               -> i64
// lency_vec_get(vec, index)        -> i64
// lency_vec_set(vec, index, value) -> void
// lency_vec_free(vec)              -> void

// ============== HashMap ==============
// HashMap 使用运行时 FFI 实现，支持 int 和 string 作为键
// 
// 注意：extern 函数直接在代码生成器中处理
// HashMap 方法通过 hashmap_int_* 函数名来识别

// FIXME: HashMapIntInt 包装暂时不可用
// 原因：返回 struct 的函数在 codegen 中有问题
// 请直接使用 hashmap_int_* 函数：
//   var map = hashmap_int_new()
//   hashmap_int_insert(map, key, value)
//   var v = hashmap_int_get(map, key)
//   var exists = hashmap_int_contains(map, key)
//   var removed = hashmap_int_remove(map, key)
//   var len = hashmap_int_len(map)

// struct HashMapIntInt {
//     int ptr  // 运行时指针
// }

// HashMapIntInt hashmap_new_int_int() {
//     return HashMapIntInt { ptr: hashmap_int_new() }
// }

// impl HashMapIntInt {
//     void insert(int key, int value) {
//         hashmap_int_insert(this.ptr, key, value)
//     }
//     int get(int key) {
//         return hashmap_int_get(this.ptr, key)
//     }
//     bool contains(int key) {
//         return hashmap_int_contains(this.ptr, key)
//     }
//     bool remove(int key) {
//         return hashmap_int_remove(this.ptr, key)
//     }
//     int size() {
//         return hashmap_int_len(this.ptr)
//     }
// }

// ============== 运行时 HashMap FFI (供参考) ==============
//
// lency_hashmap_new(capacity)              -> *mut LencyHashMap
// lency_hashmap_insert(map, key, value)    -> void
// lency_hashmap_get(map, key)              -> i64
// lency_hashmap_contains(map, key)         -> bool
// lency_hashmap_remove(map, key)           -> bool
// lency_hashmap_len(map)                   -> i64
// lency_hashmap_free(map)                  -> void

# Beryl 语言实现路线图 v2.3

> **当前状态**: v0.6 (空安全系统完成)
> **设计哲学**: 简洁 (Concise) · 规范 (Standard) · 清晰 (Clear)

---

## 🏛️ 已完成里程碑 (Completed)

### 阶段 1-4: 语言基石
- ✅ **基础架构**: Lexer, Parser, AST, Codegen (LLVM)。
- ✅ **核心类型**: `int`, `float`, `bool`, `string`。
- ✅ **控制流**: `if`, `while`, `for` (Classic & For-in), `match` (Int)。
- ✅ **集合**: 数组 (`[T; N]`) 与 动态数组 (`vec![...]`)。

### 阶段 5: 结构体与方法 (Structs & Methods)
- ✅ **结构体**: C 风格结构体定义与初始化。
- ✅ **方法**: `impl` 块，支持方法定义。
- ✅ **隐式 This**: 方法内字段的简写访问。

### 阶段 6: 空安全系统 (Null Safety)
- ✅ **显式空类型**: `T?` 表示可空，`T` 默认非空。
- ✅ **安全操作符**: `?.` (安全调用) 与 `??` (Elvis)。
- ✅ **流敏感分析**: `if x != null` 智能转换 (Smart Casts)。

---

## 🛣️ 下一步计划 (Next Steps)

### **阶段 7: 泛型 (Generics)** 🚧 *Next Sprint*
*目标: 代码复用，无需运行时开销，支持更强大的标准库。*

#### 7.1 泛型结构体
- **语法**:
  ```beryl
  struct Box<T> {
      T value
  }
  var b = Box<int> { value: 10 }
  ```
- **实现**: 
  - 符号表支持类型参数 (`T`).
  - AST 解析泛型参数。
  - 单态化 (Monomorphization): 为 `Box<int>` 和 `Box<string>` 生成不同的 LLVM Struct 类型。

#### 7.2 泛型函数
- **语法**:
  ```beryl
  fn identity<T>(x: T) -> T {
      return x
  }
  ```
- **实现**:
  - 函数签名支持类型参数。
  - 调用时根据实参类型推导 `T`，或显式指定 `id<int>(1)`.
  - 代码生成时为每个特定类型生成函数实例。

#### 7.3 升级 Vec
- **目标**: 将硬编码的 `Vec` (目前通过 `void*` hack 或 `i64` 模拟) 升级为真正的泛型 `Vec<T>`。

---

### **阶段 8: 代数数据类型 (ADTs) 与 模式匹配**
*目标: 强大的状态建模工具。*

- **枚举 (Enums)**: 支持关联数据的枚举 (`enum Option<T> { Some(T), None }`).
- **模式匹配**: 升级 `match` 表达式，支持解构 Struct 和 Enum。
- **穷尽性检查**: 编译器确保处理了所有 Enum 分支。

---

### **阶段 9: 闭包与函数式编程**
*目标: 提升语言表达力。*

- **函数类型**: `fn(int) -> bool` 作为一等公民。
- **匿名函数 (Lambdas)**: `|x| => x + 1`。
- **闭包 (Closures)**: 捕获环境变。

---

### **阶段 10: 标准库与 I/O**
*目标: 构建实用的应用程序。*

- **文件系统**: `File.read`, `File.write`。
- **字符串处理**: `split`, `trim`, `regex`。
- **系统接口**: 环境变量, 命令行参数, 时间。

---

## 📅 开发时间表 (更新)

| 冲刺 (Sprint) | 核心任务 | 状态 |
|--------|-------|-----------|
| **Sprint 1-4** | 基础架构 | ✅ 完成 |
| **Sprint 5** | 结构体与方法 | ✅ 完成 |
| **Sprint 6** | 空安全系统 | ✅ 完成 |
| **Sprint 7** | **泛型 (Generics)** | 🏁 即将开始 |
| **Sprint 8** | ADTs & 模式匹配 | 待定 |

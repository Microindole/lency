; ModuleID = 'main'
source_filename = "main"

@panic_fmt = private unnamed_addr constant [22 x i8] c"Panic at line %d: %s\0A\00", align 1
@str = private unnamed_addr constant [14 x i8] c"Array created\00", align 1
@"fmt.s\0A" = private unnamed_addr constant [4 x i8] c"%s\0A\00", align 1
@bounds_msg = private unnamed_addr constant [20 x i8] c"Index Out of Bounds\00", align 1
@"fmt.ld\0A" = private unnamed_addr constant [5 x i8] c"%ld\0A\00", align 1
@str.1 = private unnamed_addr constant [27 x i8] c"Accessing out of bounds...\00", align 1
@"fmt.s\0A.2" = private unnamed_addr constant [4 x i8] c"%s\0A\00", align 1
@bounds_msg.3 = private unnamed_addr constant [20 x i8] c"Index Out of Bounds\00", align 1
@str.4 = private unnamed_addr constant [22 x i8] c"Should not reach here\00", align 1
@"fmt.s\0A.5" = private unnamed_addr constant [4 x i8] c"%s\0A\00", align 1

declare i32 @printf(ptr, ...)

declare void @exit(i32)

define void @__beryl_panic(ptr %0, i32 %1) {
entry:
  %call_printf = call i32 (ptr, ...) @printf(ptr @panic_fmt, i32 %1, ptr %0)
  call void @exit(i32 1)
  ret void
}

declare ptr @malloc(i64)

define i64 @__beryl_main() {
entry:
  %array_literal = alloca [3 x i64], align 8
  %elem_0_ptr = getelementptr [3 x i64], ptr %array_literal, i64 0, i64 0
  store i64 10, ptr %elem_0_ptr, align 4
  %elem_1_ptr = getelementptr [3 x i64], ptr %array_literal, i64 0, i64 1
  store i64 20, ptr %elem_1_ptr, align 4
  %elem_2_ptr = getelementptr [3 x i64], ptr %array_literal, i64 0, i64 2
  store i64 30, ptr %elem_2_ptr, align 4
  %array_value = load [3 x i64], ptr %array_literal, align 4
  %arr = alloca [3 x i64], align 8
  store [3 x i64] %array_value, ptr %arr, align 4
  %printf_call = call i32 (ptr, ...) @printf(ptr @"fmt.s\0A", ptr @str)
  %arr1 = load [3 x i64], ptr %arr, align 4
  br i1 false, label %bounds_panic, label %bounds_cont

bounds_panic:                                     ; preds = %entry
  call void @__beryl_panic(ptr @bounds_msg, i32 0)
  unreachable

bounds_cont:                                      ; preds = %entry
  %array_temp = alloca [3 x i64], align 8
  store [3 x i64] %arr1, ptr %array_temp, align 4
  %elem_ptr = getelementptr [3 x i64], ptr %array_temp, i64 0, i64 1
  %elem_value = load i64, ptr %elem_ptr, align 4
  %x = alloca i64, align 8
  store i64 %elem_value, ptr %x, align 4
  %x2 = load i64, ptr %x, align 4
  %printf_call3 = call i32 (ptr, ...) @printf(ptr @"fmt.ld\0A", i64 %x2)
  %printf_call4 = call i32 (ptr, ...) @printf(ptr @"fmt.s\0A.2", ptr @str.1)
  %idx = alloca i64, align 8
  store i64 5, ptr %idx, align 4
  %arr5 = load [3 x i64], ptr %arr, align 4
  %idx6 = load i64, ptr %idx, align 4
  %is_out_of_bounds = icmp uge i64 %idx6, 3
  br i1 %is_out_of_bounds, label %bounds_panic7, label %bounds_cont8

bounds_panic7:                                    ; preds = %bounds_cont
  call void @__beryl_panic(ptr @bounds_msg.3, i32 0)
  unreachable

bounds_cont8:                                     ; preds = %bounds_cont
  %array_temp9 = alloca [3 x i64], align 8
  store [3 x i64] %arr5, ptr %array_temp9, align 4
  %elem_ptr10 = getelementptr [3 x i64], ptr %array_temp9, i64 0, i64 %idx6
  %elem_value11 = load i64, ptr %elem_ptr10, align 4
  %y = alloca i64, align 8
  store i64 %elem_value11, ptr %y, align 4
  %printf_call12 = call i32 (ptr, ...) @printf(ptr @"fmt.s\0A.5", ptr @str.4)
  ret i64 0
}

define i32 @main() {
entry:
  %call_user_main = call i64 @__beryl_main()
  %exit_code = trunc i64 %call_user_main to i32
  ret i32 %exit_code
}
